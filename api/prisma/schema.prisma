generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========== ENUMS ==========

enum UserRole {
  raiser
  solver
  both
}

enum VerificationStatus {
  unverified
  pending
  verified
  rejected
}

enum AccountStatus {
  active
  suspended
  banned
}

enum KycStatus {
  not_submitted
  submitted
  approved
  rejected
}

enum TierLevel {
  bronze
  silver
  gold
}

enum TaskCategory {
  translation
  visa_help
  navigation
  shopping
  admin_help
  other
}

enum TaskStatus {
  draft
  active
  in_progress
  completed
  cancelled
  disputed
}

enum TransactionStatus {
  pending
  escrowed
  released
  refunded
  failed
}

enum DisputeStatus {
  open
  under_review
  resolved
}

enum ResolutionOutcome {
  favor_raiser
  favor_solver
  split
  other
}

enum NotificationType {
  task_request
  task_accepted
  payment_received
  task_completed
  rating_received
  account_status
  dispute_update
}

enum DeliveryMethod {
  in_app
  email
  sms
  push
}

// ========== MODELS ==========

model User {
  id                   String              @id @default(uuid())
  email                String              @unique
  passwordHash         String
  phoneNumber          String?             @unique
  role                 UserRole
  firstName            String
  lastName             String
  profilePhotoUrl      String?
  preferredLanguage    String              @default("en")
  location             String?
  latitude             Decimal?            @db.Decimal(9, 6)
  longitude            Decimal?            @db.Decimal(9, 6)
  bio                  String?             @db.Text
  languagesSpoken      Json                @default("[]")
  verificationStatus   VerificationStatus  @default(unverified)
  accountStatus        AccountStatus       @default(active)
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @updatedAt
  lastLoginAt          DateTime?

  // Relations
  solverProfile        SolverProfile?
  tasksRaised          Task[]              @relation("TaskRaiser")
  tasksSolved          Task[]              @relation("TaskSolver")
  transactionsPaid     Transaction[]       @relation("Payer")
  transactionsReceived Transaction[]       @relation("Payee")
  ratingsGiven         Rating[]            @relation("Rater")
  ratingsReceived      Rating[]            @relation("RatedUser")
  notifications        Notification[]
  disputesRaised       Dispute[]           @relation("DisputeRaiser")
  disputesResolved     Dispute[]           @relation("DisputeResolver")
  matchRecommendations MatchRecommendation[]
  messagesSent         Message[]           @relation("MessagesSent")
  messagesReceived     Message[]           @relation("MessagesReceived")

  @@index([email])
  @@index([role])
  @@index([latitude, longitude])
  @@index([verificationStatus, role])
  @@map("users")
}

model SolverProfile {
  id                        String    @id @default(uuid())
  userId                    String    @unique
  verificationDocumentUrl   String?   @db.Text
  selfieUrl                 String?   @db.Text
  kycStatus                 KycStatus @default(not_submitted)
  kycRejectionReason        String?   @db.Text
  completedTaskCount        Int       @default(0)
  averageRating             Decimal   @default(0.0) @db.Decimal(3, 2)
  totalRatingsReceived      Int       @default(0)
  tierLevel                 TierLevel @default(bronze)
  commissionRate            Decimal   @default(30.00) @db.Decimal(4, 2)
  totalEarnings             Decimal   @default(0.00) @db.Decimal(10, 2)
  specializationTags        Json      @default("[]")
  availabilityHours         Json?
  lastActiveAt              DateTime  @default(now())
  createdAt                 DateTime  @default(now())
  updatedAt                 DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([kycStatus])
  @@index([tierLevel])
  @@index([averageRating(sort: Desc)])
  @@map("solver_profiles")
}

model Task {
  id                       String       @id @default(uuid())
  raiserId                 String
  solverId                 String?
  title                    String       @db.VarChar(200)
  description              String       @db.Text
  category                 TaskCategory
  location                 String       @db.VarChar(200)
  latitude                 Decimal?     @db.Decimal(9, 6)
  longitude                Decimal?     @db.Decimal(9, 6)
  rewardAmount             Decimal      @db.Decimal(8, 2)
  preferredLanguage        String?      @db.VarChar(10)
  preferredCompletionDate  DateTime?
  status                   TaskStatus   @default(draft)
  flaggedContent           Boolean      @default(false)
  flagReason               String?      @db.Text
  postedAt                 DateTime?
  acceptedAt               DateTime?
  completedAt              DateTime?
  createdAt                DateTime     @default(now())
  updatedAt                DateTime     @updatedAt

  // Relations
  raiser               User                  @relation("TaskRaiser", fields: [raiserId], references: [id])
  solver               User?                 @relation("TaskSolver", fields: [solverId], references: [id])
  transaction          Transaction?
  ratings              Rating[]
  matchRecommendations MatchRecommendation[]
  dispute              Dispute?
  messages             Message[]

  @@index([raiserId])
  @@index([solverId])
  @@index([status])
  @@index([category])
  @@index([latitude, longitude])
  @@index([postedAt(sort: Desc)])
  @@index([status, latitude, longitude])
  @@map("tasks")
}

model Transaction {
  id                        String            @id @default(uuid())
  taskId                    String            @unique
  payerId                   String
  payeeId                   String
  grossAmount               Decimal           @db.Decimal(8, 2)
  platformCommissionRate    Decimal           @db.Decimal(4, 2)
  platformCommissionAmount  Decimal           @db.Decimal(8, 2)
  netAmountToSolver         Decimal           @db.Decimal(8, 2)
  paymentProviderReference  String?           @db.VarChar(255)
  status                    TransactionStatus @default(pending)
  escrowedAt                DateTime?
  releasedAt                DateTime?
  refundedAt                DateTime?
  createdAt                 DateTime          @default(now())
  updatedAt                 DateTime          @updatedAt

  // Relations
  task  Task @relation(fields: [taskId], references: [id])
  payer User @relation("Payer", fields: [payerId], references: [id])
  payee User @relation("Payee", fields: [payeeId], references: [id])

  @@index([taskId])
  @@index([payerId])
  @@index([payeeId])
  @@index([status])
  @@map("transactions")
}

model Rating {
  id                   String   @id @default(uuid())
  taskId               String
  raterId              String
  ratedUserId          String
  starRating           Int      @db.SmallInt
  comment              String?  @db.Text
  helpfulVotes         Int      @default(0)
  flaggedInappropriate Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  task       Task @relation(fields: [taskId], references: [id])
  rater      User @relation("Rater", fields: [raterId], references: [id])
  ratedUser  User @relation("RatedUser", fields: [ratedUserId], references: [id])

  @@unique([taskId, raterId])
  @@index([taskId])
  @@index([raterId])
  @@index([ratedUserId])
  @@map("ratings")
}

model MatchRecommendation {
  id              String   @id @default(uuid())
  taskId          String
  solverId        String
  matchScore      Decimal  @db.Decimal(5, 2)
  proximityScore  Decimal  @db.Decimal(5, 2)
  ratingScore     Decimal  @db.Decimal(5, 2)
  experienceScore Decimal  @db.Decimal(5, 2)
  languageScore   Decimal  @db.Decimal(5, 2)
  explanation     String   @db.Text
  displayedRank   Int
  aiConfidence    Decimal  @db.Decimal(4, 2)
  createdAt       DateTime @default(now())
  expiresAt       DateTime

  // Relations
  task   Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  solver User @relation(fields: [solverId], references: [id])

  @@index([taskId])
  @@index([solverId])
  @@index([taskId, displayedRank])
  @@index([expiresAt])
  @@map("match_recommendations")
}

model Dispute {
  id                  String             @id @default(uuid())
  taskId              String             @unique
  raisedByUserId      String
  disputeReason       String             @db.Text
  raiserEvidence      Json?
  solverEvidence      Json?
  status              DisputeStatus      @default(open)
  resolutionOutcome   ResolutionOutcome?
  resolutionNotes     String?            @db.Text
  resolvedByAdminId   String?
  createdAt           DateTime           @default(now())
  resolvedAt          DateTime?
  updatedAt           DateTime           @updatedAt

  // Relations
  task            Task  @relation(fields: [taskId], references: [id])
  raisedByUser    User  @relation("DisputeRaiser", fields: [raisedByUserId], references: [id])
  resolvedByAdmin User? @relation("DisputeResolver", fields: [resolvedByAdminId], references: [id])

  @@index([taskId])
  @@index([status])
  @@index([raisedByUserId])
  @@map("disputes")
}

model Notification {
  id                 String           @id @default(uuid())
  recipientId        String
  notificationType   NotificationType
  title              String           @db.VarChar(200)
  messageContent     String           @db.Text
  deliveryMethod     DeliveryMethod
  readStatus         Boolean          @default(false)
  sentAt             DateTime         @default(now())
  readAt             DateTime?
  relatedEntityType  String?          @db.VarChar(50)
  relatedEntityId    String?

  // Relations
  recipient User @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([recipientId])
  @@index([readStatus])
  @@index([sentAt(sort: Desc)])
  @@index([recipientId, readStatus])
  @@map("notifications")
}

model Message {
  id          String   @id @default(uuid())
  taskId      String
  senderId    String
  receiverId  String
  content     String   @db.Text
  readStatus  Boolean  @default(false)
  createdAt   DateTime @default(now())
  readAt      DateTime?

  // Relations
  task     Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  sender   User @relation("MessagesSent", fields: [senderId], references: [id], onDelete: Cascade)
  receiver User @relation("MessagesReceived", fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([taskId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt(sort: Desc)])
  @@map("messages")
}
